<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kamuicode Config Manager</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- js-yaml CDN (YAMLパーサー) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <!-- Alpine.js CDN (リアクティブUI) -->
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.1/dist/cdn.min.js" defer></script>
    <style>
        /* Interフォントの読み込み */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* テーブルのレイアウトを固定し、セルの折り返しを強制 */
        table {
            table-layout: fixed;
            width: 100%;
        }
        th, td {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        /* ソートアイコン用のカスタムスタイル */
        .sort-icon {
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        th:hover .sort-icon {
            opacity: 1;
        }
        /* Alpine.js で非表示にするためのクラス */
        .hidden {
            display: none;
        }
    </style>

    <!-- Alpine.jsの関数定義 -->
    <script>
        function modelManager() {
            // LocalStorage キー
            const LS_KEY_MODE = 'kamui_config_mode';
            const LS_KEY_YAML_DATA = 'kamui_config_yaml_data';
            const LS_KEY_LAST_UPDATED = 'kamui_config_last_updated';
            const LS_KEY_PASSKEY_MODE = 'kamui_passkey_mode';
            const LS_KEY_MANUAL_PASSKEY = 'kamui_manual_passkey';

            // GitHub Raw URL
            const GITHUB_YAML_URL = 'https://raw.githubusercontent.com/Yumeno/kamuicode-config-manager/main/kamuicode_model_memo.yaml';

            // GitHub Raw URL for MCP Tool Catalog
            const CATALOG_YAML_URL = 'https://raw.githubusercontent.com/Yumeno/kamuicode-config-manager/main/mcp_tool_catalog.yaml';

            return {
                // --- 状態 ---
                masterList: [],        // 全モデルのリスト (JSON順)
                filteredList: [],      // 表示用のフィルタ済みリスト
                jsonFile: null,
                yamlFile: null,
                jsonContent: null,
                yamlContent: null,

                // --- 複数JSON対応 ---
                secondaryJsonFiles: [],    // 副JSONファイルの配列
                secondaryJsonContents: [], // パース済み副JSONの配列
                mergeMode: 'main',         // マージモード: 'main' | 'secondary' | 'both'
                mergedJsonContent: null,   // マージ済みJSON
                originalKeyMap: {},        // リネームされたキー -> 元のキー のマップ（両方を含めるモード用）
                sourceFileMap: {},         // サーバーキー -> ソースファイル名 のマップ
                // チェック状態ファイル用の変数
                checkStateFile: null,
                checkStateContent: null,
                yamlLookup: new Map(), // YAML高速検索用
                categories: [],        // フィルタ用のカテゴリ一覧
                filesReady: false,
                errorMessage: '',
                successMessage: '',

                // ソート状態 (3状態: 'asc', 'desc', 'none')
                sortState: { key: '', order: 'none' }, // key: 'name' or 'release_date'

                // --- YAML読み込みモード ---
                yamlMode: 'standard',  // 'standard' | 'custom'
                yamlLastUpdated: '',   // 最終更新日時
                isLoadingYaml: false,  // ローディング状態

                // --- フィルタとオプション ---
                filterCategory: '',
                filterText: '',

                // 出力ファイル名を変更
                outputFileName: 'mcp-kamui-code-filtered',
                // チェック状態YAMLの出力ファイル名 (デフォルト)
                outputCheckStateFileName: 'mcp-check-state',

                // --- MCPツールカタログ関連 ---
                catalogData: null,           // カタログ全体のデータ
                catalogLookup: new Map(),    // server_name -> サーバー情報のマップ
                catalogLoaded: false,        // カタログ読み込み済みフラグ
                isLoadingCatalog: false,     // カタログ読み込み中フラグ
                selectedServer: null,        // 選択されたサーバー（ツール詳細用）
                showServerDialog: false,     // ダイアログ表示フラグ

                // --- パスキー設定 ---
                passKeyMode: 'default',      // 'default' | 'manual'
                manualPassKey: '',           // 手動入力値
                showPassKey: false,          // パスキー表示/非表示

                // --- 初期化 ---
                init() {
                    // LocalStorageから設定を復元
                    const savedMode = localStorage.getItem(LS_KEY_MODE);
                    const savedYamlData = localStorage.getItem(LS_KEY_YAML_DATA);
                    const savedLastUpdated = localStorage.getItem(LS_KEY_LAST_UPDATED);
                    const savedPassKeyMode = localStorage.getItem(LS_KEY_PASSKEY_MODE);
                    const savedManualPassKey = localStorage.getItem(LS_KEY_MANUAL_PASSKEY);

                    if (savedMode) {
                        this.yamlMode = savedMode;
                    }
                    if (savedLastUpdated) {
                        this.yamlLastUpdated = savedLastUpdated;
                    }
                    if (savedYamlData) {
                        try {
                            this.yamlContent = jsyaml.load(savedYamlData, { schema: jsyaml.FAILSAFE_SCHEMA });
                        } catch (e) {
                            console.warn('保存されたYAMLの読み込みに失敗:', e);
                        }
                    }
                    // パスキー設定の復元
                    if (savedPassKeyMode) {
                        this.passKeyMode = savedPassKeyMode;
                    }
                    if (savedManualPassKey) {
                        this.manualPassKey = savedManualPassKey;
                    }
                },

                // --- モード切り替え ---
                switchMode(mode) {
                    this.yamlMode = mode;
                    localStorage.setItem(LS_KEY_MODE, mode);

                    // モード切り替え時にYAMLをクリアしない（キャッシュを保持）
                    // ただし、JSONが既にロードされている場合はリストを再構築
                    if (this.jsonContent) {
                        this.buildMasterList();
                    }
                },

                // --- 標準モード: GitHubから最新YAMLを取得 ---
                async fetchLatestYaml() {
                    this.isLoadingYaml = true;
                    this.errorMessage = '';
                    this.successMessage = '';

                    try {
                        const response = await fetch(GITHUB_YAML_URL);
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        const yamlText = await response.text();

                        // YAMLをパース
                        this.yamlContent = jsyaml.load(yamlText, { schema: jsyaml.FAILSAFE_SCHEMA });

                        // LocalStorageに保存
                        const now = new Date().toLocaleString('ja-JP');
                        localStorage.setItem(LS_KEY_YAML_DATA, yamlText);
                        localStorage.setItem(LS_KEY_LAST_UPDATED, now);
                        this.yamlLastUpdated = now;

                        this.successMessage = 'モデル情報を最新版に更新しました。';

                        // リストを再構築
                        if (this.jsonContent) {
                            this.buildMasterList();
                        }
                    } catch (e) {
                        this.errorMessage = `最新YAMLの取得に失敗しました: ${e.message}`;
                    } finally {
                        this.isLoadingYaml = false;
                    }
                },

                // --- ファイル読み込み ---
                loadJson(event) {
                    this.errorMessage = ''; // エラーメッセージをクリア
                    this.successMessage = '';
                    this.jsonFile = event.target.files[0];
                    if (this.jsonFile) {
                        this.readFile(this.jsonFile, (content) => {
                            try {
                                this.jsonContent = JSON.parse(content);
                                this.filesReady = true; // JSONが読み込めたらUI表示フラグを立てる
                                this.mergeAndBuildList(); // マージ処理を呼び出し
                            } catch (e) {
                                this.errorMessage = `JSONの解析に失敗しました: ${e.message}`;
                            }
                        });
                    }
                },

                // 副JSONファイルを読み込む
                loadSecondaryJson(event) {
                    this.errorMessage = '';
                    this.successMessage = '';
                    const files = event.target.files;
                    if (files.length > 0) {
                        // 既存の副JSONをクリアして新しいものを追加
                        this.secondaryJsonFiles = [];
                        this.secondaryJsonContents = [];

                        let loadCount = 0;
                        const totalFiles = files.length;

                        for (let i = 0; i < files.length; i++) {
                            const file = files[i];
                            this.secondaryJsonFiles.push(file);

                            this.readFile(file, (content) => {
                                try {
                                    const parsed = JSON.parse(content);
                                    this.secondaryJsonContents.push({
                                        fileName: file.name,
                                        content: parsed
                                    });
                                    loadCount++;

                                    // すべてのファイルが読み込まれたらマージ実行
                                    if (loadCount === totalFiles) {
                                        this.successMessage = `副JSON ${totalFiles}ファイルを読み込みました`;
                                        this.mergeAndBuildList();
                                    }
                                } catch (e) {
                                    this.errorMessage = `副JSON "${file.name}" の解析に失敗しました: ${e.message}`;
                                }
                            });
                        }
                    }
                },

                // 副JSONをクリア
                clearSecondaryJson() {
                    this.secondaryJsonFiles = [];
                    this.secondaryJsonContents = [];
                    this.mergedJsonContent = null;
                    this.originalKeyMap = {}; // リセット
                    this.sourceFileMap = {};  // リセット
                    // ファイル入力をリセット
                    const input = document.getElementById('secondaryJsonInput');
                    if (input) {
                        input.value = '';
                    }
                    // リストを再構築
                    if (this.jsonContent) {
                        this.mergeAndBuildList();
                    }
                },

                // マージモードを変更
                setMergeMode(mode) {
                    this.mergeMode = mode;
                    // 主JSONがある場合はリストを再構築
                    if (this.jsonContent) {
                        this.mergeAndBuildList();
                    }
                },

                // JSONをマージしてリストを構築
                mergeAndBuildList() {
                    if (!this.jsonContent) {
                        return;
                    }

                    const mainServers = this.jsonContent.mcpServers || {};
                    const mainFileName = this.jsonFile ? this.jsonFile.name : '主';
                    let mergedServers = {};
                    this.originalKeyMap = {}; // リセット
                    this.sourceFileMap = {};  // リセット

                    // 副JSONがない場合は主のみ
                    if (this.secondaryJsonContents.length === 0) {
                        mergedServers = { ...mainServers };
                        // 全て主ファイルからのソース
                        Object.keys(mainServers).forEach(key => {
                            this.sourceFileMap[key] = mainFileName;
                        });
                    } else {
                        // マージモードに応じた処理
                        switch (this.mergeMode) {
                            case 'main':
                                // 主を優先: 副を先に追加し、主で上書き
                                this.secondaryJsonContents.forEach(secondary => {
                                    const secServers = secondary.content.mcpServers || {};
                                    Object.entries(secServers).forEach(([key, value]) => {
                                        if (!mergedServers.hasOwnProperty(key) && !mainServers.hasOwnProperty(key)) {
                                            mergedServers[key] = value;
                                            this.sourceFileMap[key] = secondary.fileName;
                                        }
                                    });
                                });
                                // 主を追加（上書き）
                                Object.entries(mainServers).forEach(([key, value]) => {
                                    mergedServers[key] = value;
                                    this.sourceFileMap[key] = mainFileName;
                                });
                                break;

                            case 'secondary':
                                // 副を優先: 主を先に追加し、副で上書き
                                Object.entries(mainServers).forEach(([key, value]) => {
                                    mergedServers[key] = value;
                                    this.sourceFileMap[key] = mainFileName;
                                });
                                this.secondaryJsonContents.forEach(secondary => {
                                    const secServers = secondary.content.mcpServers || {};
                                    Object.entries(secServers).forEach(([key, value]) => {
                                        mergedServers[key] = value;
                                        this.sourceFileMap[key] = secondary.fileName;
                                    });
                                });
                                break;

                            case 'both':
                                // 両方を含める: 重複キーにはサフィックスを追加
                                const usedKeys = new Set();

                                // 主を追加
                                Object.entries(mainServers).forEach(([key, value]) => {
                                    mergedServers[key] = value;
                                    usedKeys.add(key);
                                    this.sourceFileMap[key] = mainFileName;
                                });

                                // 副を追加（重複時はリネーム）
                                this.secondaryJsonContents.forEach(secondary => {
                                    const secServers = secondary.content.mcpServers || {};
                                    const baseName = secondary.fileName.replace(/\.json$/i, '');

                                    Object.entries(secServers).forEach(([key, value]) => {
                                        if (usedKeys.has(key)) {
                                            // 重複: サフィックスを追加
                                            const newKey = `${key}_${baseName}`;
                                            mergedServers[newKey] = value;
                                            usedKeys.add(newKey);
                                            // 元のキーを記録（YAML照合用）
                                            this.originalKeyMap[newKey] = key;
                                            this.sourceFileMap[newKey] = secondary.fileName;
                                        } else {
                                            mergedServers[key] = value;
                                            usedKeys.add(key);
                                            this.sourceFileMap[key] = secondary.fileName;
                                        }
                                    });
                                });
                                break;
                        }
                    }

                    // マージ結果を保存
                    this.mergedJsonContent = { mcpServers: mergedServers };

                    // リストを構築
                    this.buildMasterList();
                },

                // カスタムモード: ローカルYAMLファイルを読み込む
                loadCustomYaml(event) {
                    this.errorMessage = '';
                    this.successMessage = '';
                    this.yamlFile = event.target.files[0];
                    if (this.yamlFile) {
                        this.readFile(this.yamlFile, (content) => {
                            try {
                                this.yamlContent = jsyaml.load(content, { schema: jsyaml.FAILSAFE_SCHEMA });

                                // LocalStorageに保存
                                const now = new Date().toLocaleString('ja-JP');
                                localStorage.setItem(LS_KEY_YAML_DATA, content);
                                localStorage.setItem(LS_KEY_LAST_UPDATED, now);
                                this.yamlLastUpdated = now;

                                this.successMessage = `カスタムYAMLを読み込みました: ${this.yamlFile.name}`;
                                this.checkReady();
                            } catch (e) {
                                this.errorMessage = `YAMLの解析に失敗しました: ${e.message}`;
                            }
                        });
                    }
                },

                // チェック状態YAMLを読み込む関数
                loadCheckState(event) {
                    this.errorMessage = '';
                    this.checkStateFile = event.target.files[0];
                    if (this.checkStateFile) {
                        this.readFile(this.checkStateFile, (content) => {
                            try {
                                this.checkStateContent = jsyaml.load(content);
                                this.applyCheckState(); // 読み込んだらすぐに適用
                            } catch (e) {
                                this.errorMessage = `状態YAMLの解析に失敗しました: ${e.message}`;
                            }
                        });
                    }
                    // ファイル選択がキャンセルされた場合も考慮し、inputの値をリセット
                    event.target.value = '';
                },
                readFile(file, callback) {
                    const reader = new FileReader();
                    reader.onload = (e) => callback(e.target.result);
                    reader.onerror = () => {
                        this.errorMessage = `ファイル ${file.name} の読み込みに失敗しました。`;
                    };
                    reader.readAsText(file);
                },

                // 日付文字列をパースするヘルパー関数
                parseDate(dateStr) {
                    if (!dateStr) return null;

                    // YYYY年MM月DD日
                    let match = dateStr.match(/(\d{4})年(\d{1,2})月(\d{1,2})日/);
                    if (match) {
                        return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
                    }

                    // YYYY年MM月頃 または YYYY年MM月
                    match = dateStr.match(/(\d{4})年(\d{1,2})月/);
                    if (match) {
                        return new Date(parseInt(match[1]), parseInt(match[2]) - 1, 1);
                    }

                    // 不明, N/A など
                    return null;
                },

                // --- データ処理 ---
                buildYamlLookup(yamlData) {
                    this.yamlLookup.clear();
                    if (!yamlData || !yamlData.ai_models) return;

                    for (const [category, models] of Object.entries(yamlData.ai_models)) {
                        if (Array.isArray(models)) {
                            models.forEach(model => {
                                if (model && model.server_name) {
                                    model.category = category; // カテゴリ情報をモデル自体に追加
                                    this.yamlLookup.set(model.server_name, model);
                                }
                            });
                        }
                    }
                },
                checkReady() {
                    // JSONコンテンツがあれば、YAMLがなくてもリスト構築を実行
                    if (this.jsonContent) {
                        this.mergeAndBuildList();
                    }
                },
                buildMasterList() {
                    this.errorMessage = '';
                    this.masterList = [];
                    this.filteredList = [];

                    try {
                        this.buildYamlLookup(this.yamlContent);
                    } catch (e) {
                        this.errorMessage = `YAMLの構造の処理中にエラー: ${e.message}`;
                        return;
                    }

                    // マージ済みJSONを使用（なければ元のjsonContent）
                    const sourceJson = this.mergedJsonContent || this.jsonContent;
                    const jsonServers = sourceJson.mcpServers;
                    if (!jsonServers) {
                        this.errorMessage = "JSONファイルに 'mcpServers' キーが見つかりません。";
                        return;
                    }

                    for (const serverName of Object.keys(jsonServers)) {
                        const serverInfo = jsonServers[serverName];
                        // リネームされたキーの場合は元のキーでYAML照合
                        const lookupKey = this.originalKeyMap[serverName] || serverName;
                        const yamlDetails = this.yamlLookup.get(lookupKey);
                        const sourceFile = this.sourceFileMap[serverName] || '';
                        let sortableDate = null; // ソート用の日付データを準備

                        if (yamlDetails) {
                            sortableDate = this.parseDate(yamlDetails.release_date); // 日付をパース
                            // YAMLに情報がある場合
                            this.masterList.push({
                                checked: true,
                                server_name: serverName,
                                category: yamlDetails.category,
                                name: yamlDetails.name,
                                release_date: yamlDetails.release_date,
                                features: yamlDetails.features,
                                sortable_date: sortableDate, // ソート用日付を追加
                                server_info: serverInfo,
                                source_file: sourceFile
                            });
                        } else {
                            // JSONにしか情報がない場合
                            this.masterList.push({
                                checked: true,
                                server_name: serverName,
                                category: '(未分類)',
                                name: serverName, // モデル名としてキーを使用
                                release_date: '',
                                features: serverInfo.description || '(解説なし)', // JSONのdescriptionを流用
                                sortable_date: null, // ソート用日付(null)を追加
                                server_info: serverInfo,
                                source_file: sourceFile
                            });
                        }
                    }
                    this.populateCategories();
                    this.applyCheckState(); // リスト構築後に状態を適用
                    this.applyFilters(); // フィルタ（ソート含む）を適用
                },
                populateCategories() {
                    const categories = new Set(this.masterList.map(m => m.category));
                    this.categories = ['(未分類)', ...Array.from(categories).filter(c => c !== '(未分類)').sort()];
                },

                // YAMLをクリアしてリストを再構築する関数
                clearYaml() {
                    this.yamlFile = null;
                    this.yamlContent = null;
                    this.yamlLookup.clear();
                    this.yamlLastUpdated = '';

                    // LocalStorageからも削除
                    localStorage.removeItem(LS_KEY_YAML_DATA);
                    localStorage.removeItem(LS_KEY_LAST_UPDATED);

                    // ファイル入力の値をリセット
                    const yamlInput = document.getElementById('customYamlInput');
                    if (yamlInput) {
                        yamlInput.value = '';
                    }
                    // YAMLなしでリストを再構築 (JSONがある場合のみ)
                    if (this.jsonContent) {
                        this.buildMasterList();
                    }
                },

                // チェック状態をクリアする関数
                clearCheckState() {
                    this.checkStateFile = null;
                    this.checkStateContent = null;
                    // inputの値をリセット
                    const checkStateInput = this.$refs.checkStateInput;
                    if (checkStateInput) {
                        checkStateInput.value = '';
                    }
                    // masterListのチェックをすべてtrueに戻す
                    if (this.masterList.length > 0) {
                        this.masterList.forEach(model => model.checked = true);
                        this.applyFilters(); // UIを更新
                    }
                },

                // チェック状態をmasterListに適用する関数
                applyCheckState() {
                    if (!this.checkStateContent || this.masterList.length === 0) {
                        return; // 状態データがないか、リストがまだない場合は何もしない
                    }

                    this.masterList.forEach(model => {
                        const serverName = model.server_name;
                        // 状態YAMLにキーが存在するかチェック
                        if (this.checkStateContent.hasOwnProperty(serverName)) {
                            model.checked = this.checkStateContent[serverName];
                        }
                        // 存在しないキーは変更しない（デフォルトのtrueのまま）
                    });

                    this.applyFilters(); // UIを更新
                },

                // --- UI操作 ---
                applyFilters() {
                    const category = this.filterCategory;
                    const text = this.filterText.toLowerCase();

                    // フィルタリング (この時点では masterList の順序 = JSON順)
                    this.filteredList = this.masterList.filter(model => {
                        const categoryMatch = !category || model.category === category;
                        const textMatch = !text ||
                                          model.name.toLowerCase().includes(text) ||
                                          (model.features && model.features.toLowerCase().includes(text)) || // featuresがnullでないかチェック
                                          model.server_name.toLowerCase().includes(text);
                        return categoryMatch && textMatch;
                    });

                    // --- ソート処理 (状態が 'none' でない場合のみ実行) ---
                    if (this.sortState.order !== 'none') {
                        const isAsc = this.sortState.order === 'asc';

                        this.filteredList.sort((a, b) => {
                            let valA, valB;

                            if (this.sortState.key === 'release_date') {
                                valA = a.sortable_date;
                                valB = b.sortable_date;

                                // null (不明な日付) の扱い: 昇順では最後、降順では最初
                                if (valA === null && valB === null) return 0;
                                if (valA === null) return isAsc ? 1 : -1;
                                if (valB === null) return isAsc ? -1 : 1;

                            } else if (this.sortState.key === 'category' || this.sortState.key === 'source_file') {
                                // カテゴリとソースは文字列ソート（空文字は最後）
                                valA = a[this.sortState.key] || '';
                                valB = b[this.sortState.key] || '';

                                if (valA === '' && valB === '') return 0;
                                if (valA === '') return isAsc ? 1 : -1;
                                if (valB === '') return isAsc ? -1 : 1;

                            } else {
                                // 'name' または他のキーでのソート
                                valA = a[this.sortState.key];
                                valB = b[this.sortState.key];
                            }

                            // 実際の比較
                            if (valA < valB) {
                                return isAsc ? -1 : 1;
                            }
                            if (valA > valB) {
                                return isAsc ? 1 : -1;
                            }
                            return 0;
                        });
                    }
                    // sortState.order が 'none' の場合は、フィルタされただけのリスト (JSON順) がそのまま使われる
                },

                // ソート実行用の関数 (3状態切り替え)
                sortBy(key) {
                    if (this.sortState.key === key) {
                        // 同じキーをクリックした場合
                        if (this.sortState.order === 'asc') {
                            this.sortState.order = 'desc';
                        } else if (this.sortState.order === 'desc') {
                            this.sortState.order = 'none'; // 解除 (JSON順に戻る)
                        } else {
                            this.sortState.order = 'asc';
                        }
                    } else {
                        // 別のキーをクリックした場合
                        this.sortState.key = key;
                        this.sortState.order = 'asc'; // 昇順で開始
                    }
                    // フィルタ（とソート）を再適用
                    this.applyFilters();
                },

                // ソートを全てリセット（JSON順に戻す）
                resetSort() {
                    this.sortState = { key: '', order: 'none' };
                    this.applyFilters();
                },

                // ソートアイコン表示用のヘルパー
                getSortIcon(key) {
                    if (this.sortState.key !== key || this.sortState.order === 'none') {
                        return '▲▼'; // デフォルト (ソート解除状態)
                    }
                    if (this.sortState.order === 'asc') {
                        return '▲'; // 昇順
                    }
                    return '▼'; // 降順
                },

                toggleAll(checkState) {
                    // フィルタリングされたリスト *だけ* をトグルする
                    this.filteredList.forEach(model => {
                        const originalModel = this.masterList.find(m => m.server_name === model.server_name);
                        if (originalModel) {
                            originalModel.checked = checkState;
                        }
                    });
                    // フィルタを再適用して表示を更新
                    this.applyFilters();
                },
                generateJson() {
                    const output = {
                        mcpServers: {}
                    };

                    this.masterList
                        .filter(model => model.checked)
                        .forEach(model => {
                            // パスキーを適用したサーバー情報を使用
                            let finalServerInfo = this.applyPassKeyToServerInfo(model.server_info);
                            output.mcpServers[model.server_name] = finalServerInfo;
                        });

                    const blob = new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;

                    const fileName = this.outputFileName.trim() ? `${this.outputFileName.trim()}.json` : 'mcp-kamui-code-filtered.json';
                    a.download = fileName;

                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                },

                // チェック状態をYAMLとして保存する関数
                generateCheckStateYaml() {
                    const output = {};
                    // masterList全体をループし、状態を記録
                    this.masterList.forEach(model => {
                        output[model.server_name] = model.checked;
                    });

                    let yamlString;
                    try {
                        yamlString = jsyaml.dump(output);
                    } catch (e) {
                        this.errorMessage = `状態YAMLの生成に失敗しました: ${e.message}`;
                        return;
                    }

                    const blob = new Blob([yamlString], { type: 'text/yaml' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;

                    // ★ ファイル名入力欄を削除したため、デフォルト名を使用
                    const fileName = `${this.outputCheckStateFileName}.yaml`;
                    a.download = fileName;

                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                },

                // --- パスキー設定関連のメソッド ---

                // パスキーモードを切り替え
                setPassKeyMode(mode) {
                    this.passKeyMode = mode;
                    localStorage.setItem(LS_KEY_PASSKEY_MODE, mode);
                },

                // 手動パスキーを保存
                saveManualPassKey() {
                    localStorage.setItem(LS_KEY_MANUAL_PASSKEY, this.manualPassKey);
                    this.successMessage = 'パスキーを保存しました。';
                    setTimeout(() => { this.successMessage = ''; }, 3000);
                },

                // パスキー表示トグル
                togglePassKeyVisibility() {
                    this.showPassKey = !this.showPassKey;
                },

                // 現在のパスキー値を取得（JSON出力用）
                getCurrentPassKeyValue() {
                    if (this.passKeyMode === 'manual' && this.manualPassKey) {
                        return this.manualPassKey;
                    }
                    return '${KAMUI_CODE_PASS_KEY}';
                },

                // サーバー設定にパスキーを適用
                applyPassKeyToServerInfo(serverInfo) {
                    // ディープコピーを作成
                    const newServerInfo = JSON.parse(JSON.stringify(serverInfo));

                    // headersが存在し、KAMUI-CODE-PASSキーがある場合のみ更新
                    if (newServerInfo.headers && newServerInfo.headers.hasOwnProperty('KAMUI-CODE-PASS')) {
                        newServerInfo.headers['KAMUI-CODE-PASS'] = this.getCurrentPassKeyValue();
                    }

                    return newServerInfo;
                },

                // --- MCPツールカタログ関連のメソッド ---

                // カタログをGitHubから読み込む
                async loadCatalog() {
                    this.isLoadingCatalog = true;
                    this.errorMessage = '';
                    this.successMessage = '';

                    try {
                        const response = await fetch(CATALOG_YAML_URL);
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        const yamlText = await response.text();

                        // YAMLをパース
                        this.catalogData = jsyaml.load(yamlText, { schema: jsyaml.FAILSAFE_SCHEMA });

                        if (this.catalogData && this.catalogData.servers) {
                            this.buildCatalogLookup();
                            this.catalogLoaded = true;
                            this.successMessage = `MCPツールカタログを読み込みました（${this.catalogData.servers.length}サーバー）`;
                        } else {
                            throw new Error('カタログデータの形式が不正です');
                        }
                    } catch (e) {
                        this.errorMessage = `カタログの読み込みに失敗しました: ${e.message}`;
                    } finally {
                        this.isLoadingCatalog = false;
                    }
                },

                // ローカルファイルからカタログを読み込む
                loadCatalogFromFile(event) {
                    this.errorMessage = '';
                    this.successMessage = '';
                    const file = event.target.files[0];
                    if (file) {
                        this.isLoadingCatalog = true;
                        this.readFile(file, (content) => {
                            try {
                                this.catalogData = jsyaml.load(content, { schema: jsyaml.FAILSAFE_SCHEMA });

                                if (this.catalogData && this.catalogData.servers) {
                                    this.buildCatalogLookup();
                                    this.catalogLoaded = true;
                                    this.successMessage = `MCPツールカタログを読み込みました（${this.catalogData.servers.length}サーバー）`;
                                } else {
                                    throw new Error('カタログデータの形式が不正です');
                                }
                            } catch (e) {
                                this.errorMessage = `カタログYAMLの解析に失敗しました: ${e.message}`;
                            } finally {
                                this.isLoadingCatalog = false;
                            }
                        });
                    }
                    event.target.value = '';
                },

                // カタログのLookupを構築（server_name -> サーバー情報）
                buildCatalogLookup() {
                    this.catalogLookup.clear();
                    if (!this.catalogData || !this.catalogData.servers) return;

                    this.catalogData.servers.forEach(server => {
                        if (server && server.id) {
                            this.catalogLookup.set(server.id, server);
                        }
                    });
                },

                // server_nameに対応するカタログ情報を取得
                getCatalogServer(serverName) {
                    // リネームされたキーの場合は元のキーで照合
                    const lookupKey = this.originalKeyMap[serverName] || serverName;
                    return this.catalogLookup.get(lookupKey);
                },

                // server_nameに対応するツール数を取得
                getToolCount(serverName) {
                    // リネームされたキーの場合は元のキーで照合
                    const lookupKey = this.originalKeyMap[serverName] || serverName;
                    const server = this.catalogLookup.get(lookupKey);
                    return server && server.tools ? server.tools.length : 0;
                },

                // サーバー詳細ダイアログを開く（server_nameから）
                openToolDialog(serverName) {
                    // リネームされたキーの場合は元のキーで照合
                    const lookupKey = this.originalKeyMap[serverName] || serverName;
                    const server = this.catalogLookup.get(lookupKey);
                    if (server) {
                        this.selectedServer = server;
                        this.showServerDialog = true;
                        document.body.style.overflow = 'hidden';
                    }
                },

                // サーバー詳細ダイアログを閉じる
                closeServerDialog() {
                    this.showServerDialog = false;
                    this.selectedServer = null;
                    document.body.style.overflow = '';
                },

                // ツールをsubmit -> status -> resultの順にソートして取得
                getSortedTools(server) {
                    if (!server || !server.tools) return [];

                    const order = { 'submit': 0, 'status': 1, 'result': 2 };

                    return [...server.tools].sort((a, b) => {
                        // ツール名の末尾からタイプを判定
                        const getType = (name) => {
                            if (name.endsWith('_submit') || name.includes('submit')) return 'submit';
                            if (name.endsWith('_status') || name.includes('status')) return 'status';
                            if (name.endsWith('_result') || name.includes('result')) return 'result';
                            return 'other';
                        };

                        const typeA = getType(a.name);
                        const typeB = getType(b.name);
                        const orderA = order[typeA] !== undefined ? order[typeA] : 3;
                        const orderB = order[typeB] !== undefined ? order[typeB] : 3;

                        return orderA - orderB;
                    });
                },

                // カタログをクリア
                clearCatalog() {
                    this.catalogData = null;
                    this.catalogLookup.clear();
                    this.catalogLoaded = false;
                    this.selectedServer = null;
                    this.showServerDialog = false;
                }
            };
        }
    </script>
</head>
<body class="bg-gray-100 text-gray-900">

    <div class="container mx-auto p-4 lg:p-8" x-data="modelManager()" x-init="init()">
        <header class="mb-6">
            <!-- タイトル -->
            <h1 class="text-3xl font-bold text-gray-800">kamuicode Config Manager</h1>
            <p class="text-gray-600 mt-1">JSON (mcpServers) と モデル情報 (YAML) を使ってAIモデル構成を管理します。</p>
        </header>

        <!-- エラーメッセージ -->
        <template x-if="errorMessage">
            <div class="mb-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative" role="alert">
                <strong class="font-bold">エラー: </strong>
                <span class="block sm:inline" x-text="errorMessage"></span>
            </div>
        </template>

        <!-- 成功メッセージ -->
        <template x-if="successMessage">
            <div class="mb-4 bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded-lg relative" role="alert">
                <span class="block sm:inline" x-text="successMessage"></span>
            </div>
        </template>

        <!-- パスキー設定セクション -->
        <div class="bg-white p-6 rounded-lg shadow-md mb-6">
            <h2 class="text-lg font-semibold mb-3">パスキー設定 (KAMUI-CODE-PASS)</h2>
            <p class="text-sm text-gray-600 mb-4">kamuicodeリモートMCPサーバーに接続するためのパスキーを設定します。</p>

            <div class="space-y-4">
                <!-- デフォルト設定 -->
                <label class="flex items-start space-x-3 p-3 border rounded-lg cursor-pointer transition-colors"
                       :class="passKeyMode === 'default' ? 'border-orange-500 bg-orange-50' : 'border-gray-200 hover:bg-gray-50'">
                    <input type="radio" name="passKeyMode" value="default"
                           x-model="passKeyMode" @change="setPassKeyMode('default')"
                           class="mt-1 h-4 w-4 text-orange-600 border-gray-300 focus:ring-orange-500">
                    <div class="flex-1">
                        <span class="block font-medium text-gray-900">デフォルト設定</span>
                        <span class="block text-xs text-gray-500 mt-1">環境変数プレースホルダー <code class="bg-gray-100 px-1 py-0.5 rounded text-orange-600">${KAMUI_CODE_PASS_KEY}</code> を使用します</span>
                        <span class="block text-xs text-gray-400 mt-1">※ Claude Desktopなどで環境変数を設定している場合に使用</span>
                    </div>
                </label>

                <!-- 手動入力 -->
                <label class="flex items-start space-x-3 p-3 border rounded-lg cursor-pointer transition-colors"
                       :class="passKeyMode === 'manual' ? 'border-orange-500 bg-orange-50' : 'border-gray-200 hover:bg-gray-50'">
                    <input type="radio" name="passKeyMode" value="manual"
                           x-model="passKeyMode" @change="setPassKeyMode('manual')"
                           class="mt-1 h-4 w-4 text-orange-600 border-gray-300 focus:ring-orange-500">
                    <div class="flex-1">
                        <span class="block font-medium text-gray-900">パスキーを直接入力</span>
                        <span class="block text-xs text-gray-500 mt-1">発行されたパスキーを直接設定します</span>

                        <!-- 手動入力詳細 (選択時のみ表示) -->
                        <template x-if="passKeyMode === 'manual'">
                            <div class="mt-3 pt-3 border-t border-gray-200">
                                <div class="flex items-center gap-2">
                                    <div class="relative flex-1">
                                        <input :type="showPassKey ? 'text' : 'password'"
                                               x-model="manualPassKey"
                                               placeholder="パスキーを入力..."
                                               class="block w-full px-3 py-2 pr-10 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500 text-sm font-mono"
                                               @click.stop>
                                        <button type="button"
                                                @click.stop="togglePassKeyVisibility()"
                                                class="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-gray-600">
                                            <template x-if="!showPassKey">
                                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                                                </svg>
                                            </template>
                                            <template x-if="showPassKey">
                                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path>
                                                </svg>
                                            </template>
                                        </button>
                                    </div>
                                    <button type="button"
                                            @click.stop="saveManualPassKey()"
                                            class="px-4 py-2 text-sm font-medium text-white bg-orange-600 rounded-lg hover:bg-orange-700 transition-colors whitespace-nowrap">
                                        保存
                                    </button>
                                </div>
                                <p class="mt-2 text-xs text-gray-500">※ パスキーはブラウザのLocalStorageに保存されます</p>
                            </div>
                        </template>
                    </div>
                </label>
            </div>

            <!-- 現在の設定表示 -->
            <div class="mt-4 p-3 bg-gray-50 rounded-lg">
                <span class="text-sm font-medium text-gray-700">出力時の値: </span>
                <code class="text-sm bg-white px-2 py-1 rounded border border-gray-200" x-text="passKeyMode === 'manual' && manualPassKey ? '****' + manualPassKey.slice(-4) : '${KAMUI_CODE_PASS_KEY}'"></code>
            </div>
        </div>

        <!-- 1. ファイル入力エリア (JSONとYAML) -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <!-- 1. JSON読み込み（複数JSON対応） -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-lg font-semibold mb-3">1. mcpServers (.json)</h2>

                <!-- 主JSON入力 -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">
                        主 (Main) JSON <span class="text-red-500">*</span>
                    </label>
                    <input type="file" @change="loadJson" accept=".json" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors">
                    <p class="mt-1 text-xs text-gray-500">基本となる設定ファイルを選択してください</p>
                </div>

                <!-- 副JSON入力 -->
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-1">
                        <label class="block text-sm font-medium text-gray-700">
                            副 (Secondary) JSON <span class="text-gray-400 text-xs">(任意・複数可)</span>
                        </label>
                        <template x-if="secondaryJsonContents.length > 0">
                            <button @click="clearSecondaryJson" class="px-2 py-1 text-xs font-medium text-red-700 bg-red-100 rounded-lg hover:bg-red-200 transition-colors">
                                クリア
                            </button>
                        </template>
                    </div>
                    <input type="file" id="secondaryJsonInput" @change="loadSecondaryJson" accept=".json" multiple class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100 transition-colors">
                    <p class="mt-1 text-xs text-gray-500">追加の設定ファイルを複数選択できます</p>

                    <!-- 読み込み済み副JSONの表示 -->
                    <template x-if="secondaryJsonContents.length > 0">
                        <div class="mt-2 p-2 bg-green-50 rounded-lg">
                            <p class="text-xs text-green-700 font-medium mb-1">読み込み済み:</p>
                            <ul class="text-xs text-green-600 space-y-0.5">
                                <template x-for="(sec, idx) in secondaryJsonContents" :key="idx">
                                    <li class="flex items-center">
                                        <span class="mr-1">•</span>
                                        <span x-text="sec.fileName"></span>
                                        <span class="ml-1 text-green-500" x-text="`(${Object.keys(sec.content.mcpServers || {}).length}サーバー)`"></span>
                                    </li>
                                </template>
                            </ul>
                        </div>
                    </template>
                </div>

                <!-- マージ設定（副JSONがある場合のみ表示） -->
                <template x-if="secondaryJsonContents.length > 0">
                    <div class="border-t border-gray-200 pt-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">マージ設定（競合解決ルール）</label>
                        <div class="space-y-2">
                            <!-- 主を優先 -->
                            <label class="flex items-start space-x-2 p-2 border rounded-lg cursor-pointer transition-colors"
                                   :class="mergeMode === 'main' ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:bg-gray-50'">
                                <input type="radio" name="mergeMode" value="main"
                                       x-model="mergeMode" @change="setMergeMode('main')"
                                       class="mt-0.5 h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                <div class="flex-1">
                                    <span class="block text-sm font-medium text-gray-900">🔘 主を優先 (Default)</span>
                                    <span class="block text-xs text-gray-500">重複キーは主の設定を使用し、副は無視</span>
                                </div>
                            </label>

                            <!-- 副を優先 -->
                            <label class="flex items-start space-x-2 p-2 border rounded-lg cursor-pointer transition-colors"
                                   :class="mergeMode === 'secondary' ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:bg-gray-50'">
                                <input type="radio" name="mergeMode" value="secondary"
                                       x-model="mergeMode" @change="setMergeMode('secondary')"
                                       class="mt-0.5 h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                <div class="flex-1">
                                    <span class="block text-sm font-medium text-gray-900">⚪ 副を優先 (Override)</span>
                                    <span class="block text-xs text-gray-500">重複キーは副の設定で上書き</span>
                                </div>
                            </label>

                            <!-- 両方を含める -->
                            <label class="flex items-start space-x-2 p-2 border rounded-lg cursor-pointer transition-colors"
                                   :class="mergeMode === 'both' ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:bg-gray-50'">
                                <input type="radio" name="mergeMode" value="both"
                                       x-model="mergeMode" @change="setMergeMode('both')"
                                       class="mt-0.5 h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                <div class="flex-1">
                                    <span class="block text-sm font-medium text-gray-900">⚪ 両方を含める (Keep Both)</span>
                                    <span class="block text-xs text-gray-500">重複キーは両方表示（副にサフィックス付与）</span>
                                </div>
                            </label>
                        </div>
                    </div>
                </template>
            </div>

            <!-- 2. モデル情報 (YAML) 読み込み - 新UI -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-lg font-semibold">2. モデル情報 (YAML) <span class="text-sm font-normal text-gray-500">(任意)</span></h2>
                    <template x-if="yamlContent">
                        <button @click="clearYaml" class="px-2 py-1 text-xs font-medium text-red-700 bg-red-100 rounded-lg hover:bg-red-200 transition-colors">クリア</button>
                    </template>
                </div>

                <!-- モード選択ラジオボタン -->
                <div class="space-y-4">
                    <!-- 標準モード -->
                    <label class="flex items-start space-x-3 p-3 border rounded-lg cursor-pointer transition-colors"
                           :class="yamlMode === 'standard' ? 'border-indigo-500 bg-indigo-50' : 'border-gray-200 hover:bg-gray-50'">
                        <input type="radio" name="yamlMode" value="standard"
                               x-model="yamlMode" @change="switchMode('standard')"
                               class="mt-1 h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                        <div class="flex-1">
                            <span class="block font-medium text-gray-900">標準モデル情報を使用</span>
                            <span class="block text-xs text-gray-500 mt-1">GitHubから最新のモデル定義を取得します</span>

                            <!-- 標準モード詳細 (選択時のみ表示) -->
                            <template x-if="yamlMode === 'standard'">
                                <div class="mt-3 pt-3 border-t border-gray-200">
                                    <!-- 未読み込み時: 読み込みを促すUI -->
                                    <template x-if="!yamlLastUpdated && !isLoadingYaml">
                                        <div class="text-center">
                                            <p class="text-xs text-amber-600 mb-2">モデル情報がまだ読み込まれていません</p>
                                            <button @click="fetchLatestYaml"
                                                    class="w-full px-4 py-2 text-sm font-medium text-white bg-green-600 rounded-lg hover:bg-green-700 transition-colors">
                                                モデル情報を読み込む
                                            </button>
                                        </div>
                                    </template>
                                    <!-- 読み込み中 -->
                                    <template x-if="isLoadingYaml">
                                        <div class="text-center">
                                            <p class="text-xs text-gray-600">読み込み中...</p>
                                        </div>
                                    </template>
                                    <!-- 読み込み済み: 更新日時と更新ボタン -->
                                    <template x-if="yamlLastUpdated && !isLoadingYaml">
                                        <div class="flex items-center justify-between">
                                            <div class="text-xs text-gray-600">
                                                <span>最終更新: <span x-text="yamlLastUpdated"></span></span>
                                            </div>
                                            <button @click="fetchLatestYaml"
                                                    class="px-3 py-1.5 text-xs font-medium text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 transition-colors">
                                                最新に更新
                                            </button>
                                        </div>
                                    </template>
                                </div>
                            </template>
                        </div>
                    </label>

                    <!-- カスタムモード -->
                    <label class="flex items-start space-x-3 p-3 border rounded-lg cursor-pointer transition-colors"
                           :class="yamlMode === 'custom' ? 'border-indigo-500 bg-indigo-50' : 'border-gray-200 hover:bg-gray-50'">
                        <input type="radio" name="yamlMode" value="custom"
                               x-model="yamlMode" @change="switchMode('custom')"
                               class="mt-1 h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                        <div class="flex-1">
                            <span class="block font-medium text-gray-900">カスタムYAMLファイルを使用</span>
                            <span class="block text-xs text-gray-500 mt-1">ローカルの任意のYAMLファイルを指定できます</span>

                            <!-- カスタムモード詳細 (選択時のみ表示) -->
                            <template x-if="yamlMode === 'custom'">
                                <div class="mt-3 pt-3 border-t border-gray-200">
                                    <input type="file" id="customYamlInput" @change="loadCustomYaml" accept=".yaml, .yml"
                                           class="block w-full text-sm text-gray-500 file:mr-4 file:py-1.5 file:px-3 file:rounded-lg file:border-0 file:text-xs file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 transition-colors">
                                    <template x-if="yamlLastUpdated && yamlMode === 'custom'">
                                        <div class="mt-2 text-xs text-gray-600">
                                            最終読み込み: <span x-text="yamlLastUpdated"></span>
                                        </div>
                                    </template>
                                </div>
                            </template>
                        </div>
                    </label>
                </div>
            </div>
        </div>

        <!-- ★ 3. モデル一覧テーブル (ファイルが準備OKなら表示) -->
        <template x-if="filesReady">
            <div class="bg-white rounded-lg shadow-md overflow-hidden">
                <!-- ★★★ ヘッダー: タイトル と 状態I/Oボタン ★★★ -->
                <div class="p-4 md:p-6 border-b border-gray-200">
                    <div class="flex flex-col md:flex-row justify-between md:items-center gap-3">
                        <!-- タイトル -->
                        <h2 class="text-xl font-semibold">
                            3. モデル一覧
                            <span class="text-base font-normal text-gray-600" x-text="`(${filteredList.length} / ${masterList.length} 件)`"></span>
                        </h2>

                        <!-- ボタングループ -->
                        <div class="flex flex-wrap items-center gap-2">
                            <!-- ツールカタログ読み込み -->
                            <button @click="loadCatalog"
                                    :disabled="isLoadingCatalog"
                                    class="px-3 py-1.5 text-xs font-medium text-purple-700 bg-purple-100 rounded-lg hover:bg-purple-200 transition-colors disabled:opacity-50">
                                <span x-show="!isLoadingCatalog && !catalogLoaded">ツールカタログ読込</span>
                                <span x-show="isLoadingCatalog">読込中...</span>
                                <span x-show="catalogLoaded && !isLoadingCatalog">カタログ読込済</span>
                            </button>
                            <template x-if="catalogLoaded">
                                <button @click="clearCatalog" class="px-2 py-1 text-xs font-medium text-red-700 bg-red-100 rounded-lg hover:bg-red-200 transition-colors">
                                    カタログクリア
                                </button>
                            </template>

                            <span class="text-gray-300">|</span>

                            <!-- 状態読み込みボタン (inputを隠す) -->
                            <input type="file" @change="loadCheckState" accept=".yaml, .yml" id="checkStateInput" x-ref="checkStateInput" class="hidden">
                            <button type="button" @click="$refs.checkStateInput.click()" class="px-3 py-1.5 text-xs font-medium text-green-700 bg-green-100 rounded-lg hover:bg-green-200 transition-colors">
                                状態を読み込む
                            </button>
                            <!-- 状態保存ボタン -->
                            <button @click="generateCheckStateYaml" class="px-3 py-1.5 text-xs font-medium text-green-800 bg-green-200 rounded-lg hover:bg-green-300 transition-colors">
                                状態を保存
                            </button>
                            <!-- クリアボタン (読み込み後) -->
                            <template x-if="checkStateContent">
                                <button @click="clearCheckState" class="flex-shrink-0 px-2 py-1 text-xs font-medium text-red-700 bg-red-100 rounded-lg hover:bg-red-200 transition-colors" title="読み込んだ状態をクリア">
                                    クリア
                                </button>
                            </template>
                        </div>
                    </div>
                </div>

                <!-- ★★★ フィルタ と 一括チェック/解除 ★★★ -->
                <div class="p-4 md:p-6 border-b border-gray-200 bg-gray-50/50">
                    <!-- フィルタ機能 -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <label for="filterCategory" class="block text-sm font-medium text-gray-700">カテゴリで絞り込み</label>
                            <select id="filterCategory" x-model="filterCategory" @change="applyFilters" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <option value="">すべてのカテゴリ</option>
                                <template x-for="category in categories" :key="category">
                                    <option :value="category" x-text="category"></option>
                                </template>
                            </select>
                        </div>
                        <div>
                            <label for="filterText" class="block text-sm font-medium text-gray-700">テキストで絞り込み</label>
                            <input type="search" id="filterText" x-model="filterText" @input.debounce.300ms="applyFilters" placeholder="モデル名, 解説..." class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        </div>
                    </div>

                    <hr class="my-4 border-gray-200">

                    <!-- 一括チェック/解除ボタン と ソート解除 -->
                    <div class="flex justify-between items-center">
                        <!-- ソート解除ボタン（ソート中のみ表示） -->
                        <div>
                            <template x-if="sortState.order !== 'none'">
                                <button @click="resetSort" class="px-3 py-1.5 text-xs font-medium text-orange-700 bg-orange-100 rounded-lg hover:bg-orange-200 transition-colors">
                                    ソート解除 (JSON順に戻す)
                                </button>
                            </template>
                        </div>
                        <!-- 一括チェック/解除ボタン -->
                        <div class="flex space-x-2">
                             <button @click="toggleAll(true)" class="px-3 py-1.5 text-xs font-medium text-blue-700 bg-blue-100 rounded-lg hover:bg-blue-200 transition-colors">フィルタ内すべてチェック</button>
                             <button @click="toggleAll(false)" class="px-3 py-1.5 text-xs font-medium text-gray-700 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">フィルタ内すべて解除</button>
                        </div>
                    </div>
                </div>

                <!-- テーブルコンテナ -->
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th scope="col" class="w-16 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    <!-- チェックボックスヘッダー -->
                                </th>
                                <!-- 「カテゴリ」のヘッダー (ソート対応) -->
                                <th scope="col" class="w-48 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" @click="sortBy('category')">
                                    <div class="flex items-center">
                                        カテゴリ
                                        <span class="ml-1 text-gray-700 sort-icon"
                                              :class="{ 'opacity-100': sortState.key === 'category' }"
                                              x-text="getSortIcon('category')"></span>
                                    </div>
                                </th>

                                <!-- 「モデル名」のヘッダー (ソート対応) -->
                                <th scope="col" class="w-64 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" @click="sortBy('name')">
                                    <div class="flex items-center">
                                        モデル名
                                        <span class="ml-1 text-gray-700 sort-icon"
                                              :class="{ 'opacity-100': sortState.key === 'name' }"
                                              x-text="getSortIcon('name')"></span>
                                    </div>
                                </th>

                                <!-- 「リリース時期」のヘッダー (ソート対応) -->
                                <th scope="col" class="w-40 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" @click="sortBy('release_date')">
                                    <div class="flex items-center">
                                        リリース時期
                                        <span class="ml-1 text-gray-700 sort-icon"
                                              :class="{ 'opacity-100': sortState.key === 'release_date' }"
                                              x-text="getSortIcon('release_date')"></span>
                                    </div>
                                </th>
                                <!-- 「ソース」のヘッダー (副JSONがある場合のみ表示・ソート対応) -->
                                <template x-if="secondaryJsonContents.length > 0">
                                    <th scope="col" class="w-36 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100" @click="sortBy('source_file')">
                                        <div class="flex items-center">
                                            ソース
                                            <span class="ml-1 text-gray-700 sort-icon"
                                                  :class="{ 'opacity-100': sortState.key === 'source_file' }"
                                                  x-text="getSortIcon('source_file')"></span>
                                        </div>
                                    </th>
                                </template>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">解説</th>
                                <th scope="col" class="w-28 px-4 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">ツール詳細</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            <template x-if="filteredList.length === 0">
                                <tr>
                                    <td :colspan="secondaryJsonContents.length > 0 ? 7 : 6" class="px-6 py-10 text-center text-gray-500">
                                        ファイルが読み込まれていないか、フィルタに一致するモデルがありません。
                                    </td>
                                </tr>
                            </template>
                            <template x-for="model in filteredList" :key="model.server_name">
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-4 text-center">
                                        <!-- masterList の状態を直接トグルする -->
                                        <input type="checkbox" x-model="masterList.find(m => m.server_name === model.server_name).checked" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                    </td>
                                    <td class="px-4 py-4 text-sm text-gray-600" x-text="model.category"></td>
                                    <td class="px-4 py-4 text-sm font-medium text-gray-900">
                                        <span x-text="model.name"></span>
                                        <span class="block text-xs text-gray-400" x-text="model.server_name"></span>
                                    </td>
                                    <td class="px-4 py-4 text-sm text-gray-600" x-text="model.release_date"></td>
                                    <!-- ソース列 (副JSONがある場合のみ表示) -->
                                    <template x-if="secondaryJsonContents.length > 0">
                                        <td class="px-4 py-4 text-sm">
                                            <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium"
                                                  :class="model.source_file === (jsonFile ? jsonFile.name : '主') ? 'bg-blue-100 text-blue-800' : 'bg-green-100 text-green-800'"
                                                  x-text="model.source_file"></span>
                                        </td>
                                    </template>
                                    <td class="px-4 py-4 text-sm text-gray-600" x-text="model.features"></td>
                                    <td class="px-4 py-4 text-center">
                                        <template x-if="catalogLoaded && getCatalogServer(model.server_name)">
                                            <button @click.stop="openToolDialog(model.server_name)"
                                                    class="px-2 py-1 text-xs font-medium text-purple-700 bg-purple-100 rounded hover:bg-purple-200 transition-colors">
                                                詳細 (<span x-text="getToolCount(model.server_name)"></span>)
                                            </button>
                                        </template>
                                        <template x-if="!catalogLoaded">
                                            <span class="text-xs text-gray-400">-</span>
                                        </template>
                                        <template x-if="catalogLoaded && !getCatalogServer(model.server_name)">
                                            <span class="text-xs text-gray-400">N/A</span>
                                        </template>
                                    </td>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
            </div>
        </template>

        <!-- ★ 4. JSONを出力 (ファイルが準備OKなら表示) -->
        <template x-if="filesReady">
            <div class="mt-6 bg-white p-6 rounded-lg shadow-md">
                <!-- ★ 見出し番号を変更 -->
                <h2 class="text-xl font-semibold mb-4">4. 最終JSONを出力</h2>
                <div class="flex flex-col md:flex-row gap-4">
                    <div class="flex-grow">
                        <label for="outputFileName" class="block text-sm font-medium text-gray-700">出力JSONファイル名</label>
                        <input type="text" id="outputFileName" x-model="outputFileName" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                    </div>
                    <div class="flex-shrink-0 md:mt-6">
                        <button @click="generateJson" class="w-full md:w-auto px-6 py-2.5 text-base font-semibold text-white bg-indigo-600 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-colors">
                            JSONを生成して保存
                        </button>
                    </div>
                </div>
            </div>
        </template>

        <!-- ==================== ツール詳細ダイアログ ==================== -->
        <template x-if="showServerDialog && selectedServer">
            <div class="fixed inset-0 z-50 overflow-y-auto" @keydown.escape.window="closeServerDialog()">
                <!-- オーバーレイ -->
                <div class="fixed inset-0 bg-black bg-opacity-50 transition-opacity" @click="closeServerDialog()"></div>

                <!-- ダイアログ本体 -->
                <div class="flex min-h-full items-center justify-center p-4">
                    <div class="relative bg-white rounded-xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden" @click.stop>
                        <!-- ヘッダー -->
                        <div class="sticky top-0 bg-white border-b border-gray-200 px-6 py-4 flex justify-between items-start z-10">
                            <div class="flex-1 pr-4">
                                <h3 class="text-xl font-bold text-gray-900 mb-1" x-text="selectedServer.id"></h3>
                                <p class="text-sm text-gray-500 break-all" x-text="selectedServer.url"></p>
                            </div>
                            <button @click="closeServerDialog()"
                                    class="p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>

                        <!-- コンテンツ -->
                        <div class="px-6 py-4 overflow-y-auto" style="max-height: calc(90vh - 100px);">
                            <!-- ツール一覧 -->
                            <h4 class="text-lg font-semibold text-gray-800 mb-4">ツール一覧 (<span x-text="selectedServer.tools ? selectedServer.tools.length : 0"></span>)</h4>

                            <template x-if="selectedServer.tools && selectedServer.tools.length > 0">
                                <div class="space-y-4">
                                    <template x-for="(tool, index) in getSortedTools(selectedServer)" :key="index">
                                        <div class="border border-gray-200 rounded-lg overflow-hidden">
                                            <!-- ツールヘッダー -->
                                            <div class="bg-gray-50 px-4 py-3 border-b border-gray-200">
                                                <h5 class="font-mono font-semibold text-purple-700" x-text="tool.name"></h5>
                                            </div>
                                            <!-- ツール詳細 -->
                                            <div class="p-4">
                                                <!-- 説明 -->
                                                <p class="text-sm text-gray-700 mb-4" x-text="tool.description"></p>

                                                <!-- 入力スキーマ -->
                                                <template x-if="tool.inputSchema">
                                                    <div>
                                                        <h6 class="text-sm font-semibold text-gray-600 mb-2">入力パラメータ</h6>
                                                        <div class="bg-gray-50 rounded-lg p-3">
                                                            <template x-if="tool.inputSchema.properties">
                                                                <div class="space-y-3">
                                                                    <template x-for="(prop, propName) in tool.inputSchema.properties" :key="propName">
                                                                        <div class="flex flex-col sm:flex-row sm:items-start gap-1 sm:gap-3 p-2 bg-white rounded border border-gray-100">
                                                                            <div class="flex items-center gap-2">
                                                                                <code class="text-sm font-mono text-purple-600" x-text="propName"></code>
                                                                                <span class="px-1.5 py-0.5 text-xs font-medium bg-blue-100 text-blue-700 rounded" x-text="prop.type"></span>
                                                                                <template x-if="tool.inputSchema.required && tool.inputSchema.required.includes(propName)">
                                                                                    <span class="px-1.5 py-0.5 text-xs font-medium bg-red-100 text-red-700 rounded">必須</span>
                                                                                </template>
                                                                            </div>
                                                                            <p class="text-sm text-gray-600 flex-1" x-text="prop.description || '(説明なし)'"></p>
                                                                        </div>
                                                                    </template>
                                                                </div>
                                                            </template>
                                                            <template x-if="!tool.inputSchema.properties">
                                                                <p class="text-sm text-gray-500 italic">パラメータなし</p>
                                                            </template>
                                                        </div>
                                                    </div>
                                                </template>
                                            </div>
                                        </div>
                                    </template>
                                </div>
                            </template>

                            <template x-if="!selectedServer.tools || selectedServer.tools.length === 0">
                                <div class="text-center py-8 text-gray-500">
                                    このサーバーにはツールが登録されていません。
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </template>

    </div> <!-- /x-data="modelManager" -->
</body>
</html>
